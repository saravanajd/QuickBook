<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NuGet.PackageManagement</name>
    </assembly>
    <members>
        <member name="T:NuGet.PackageManagement.IInstallationCompatibility">
            <summary>
            Validates the compatibility of a installed packages for the given project type. This
            component should be used after packages have been downloaded to disk but have not yet
            been installed to the project. If an installed package is not compatibile with the given
            project, an exception is thrown. The checks performed by this class are based on 
            package minimum client versions and package types.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IInstallationCompatibility.EnsurePackageCompatibility(NuGet.ProjectManagement.NuGetProject,NuGet.Common.INuGetPathContext,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.Commands.RestoreResult)">
            <summary>
            Validates the compatibility of a multiple installed packages for the given project type.
            </summary>
            <param name="nuGetProject">
            The NuGet project. The type of the NuGet project determines the sorts or validations that are done.
            </param>
            <param name="pathContext">The path context used to find the installed packages.</param>
            <param name="nuGetProjectActions">The project actions.</param>
            <param name="restoreResult">The restore result generated during installation.</param>
        </member>
        <member name="M:NuGet.PackageManagement.IInstallationCompatibility.EnsurePackageCompatibility(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.DownloadResourceResult)">
            <summary>
            Validates the compatibility of a single downloaded package.
            </summary>
            <param name="nuGetProject">
            The NuGet project. The type of the NuGet project determines the sorts or validations that are done.
            </param>
            <param name="packageIdentity">The identity of that package contained in the download result.</param>
            <param name="resourceResult">The downloaded package.</param>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetPackageManager">
            <summary>
            NuGetPackageManager orchestrates a nuget package operation such as an install or uninstall
            It is to be called by various NuGet Clients including the custom third-party ones
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.NuGetPackageManager.BatchStart">
            <summary>
            Event to be raised when batch processing of install/ uninstall packages starts at a project level
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.NuGetPackageManager.BatchEnd">
            <summary>
            Event to be raised when batch processing of install/ uninstall packages ends at a project level
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.#ctor(NuGet.Protocol.Core.Types.ISourceRepositoryProvider,NuGet.Configuration.ISettings,System.String)">
            <summary>
            To construct a NuGetPackageManager that does not need a SolutionManager like NuGet.exe
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.#ctor(NuGet.Protocol.Core.Types.ISourceRepositoryProvider,NuGet.Configuration.ISettings,NuGet.PackageManagement.ISolutionManager,NuGet.PackageManagement.IDeleteOnRestartManager)">
            <summary>
            To construct a NuGetPackageManager with a mandatory SolutionManager lke VS
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetPackageManager.GlobalPackageFolderRepositories">
            <summary>
            SourceRepositories for the user global package folder and all fallback package folders.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs the latest version of the given <paramref name="packageId" /> to NuGetProject
            <paramref name="nuGetProject" /> <paramref name="resolutionContext" /> and
            <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs the latest version of the given <paramref name="packageId" /> to NuGetProject
            <paramref name="nuGetProject" /> <paramref name="resolutionContext" /> and
            <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs the latest version of the given
            <paramref name="packageId" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs the latest version of the given
            <paramref name="packageId" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs given <paramref name="packageIdentity" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs given <paramref name="packageIdentity" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs given <paramref name="packageIdentity" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.InstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Installs given <paramref name="packageIdentity" /> to NuGetProject <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewInstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Gives the preview as a list of NuGetProjectActions that will be performed to install
            <paramref name="packageId" /> into <paramref name="nuGetProject" /> <paramref name="resolutionContext" />
            and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewInstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Gives the preview as a list of NuGetProjectActions that will be performed to install
            <paramref name="packageId" /> into <paramref name="nuGetProject" /> <paramref name="resolutionContext" />
            and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewUpdatePackagesForBuildIntegratedAsync(System.String,System.Collections.Generic.List{NuGet.Packaging.Core.PackageIdentity},NuGet.ProjectManagement.NuGetProject,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Update Package logic specific to build integrated style NuGet projects
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewUpdatePackagesForClassicAsync(System.String,System.Collections.Generic.List{NuGet.Packaging.Core.PackageIdentity},NuGet.ProjectManagement.NuGetProject,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Update Package logic specific to classic style NuGet projects
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.GetInstalledPackagesInDependencyOrder(NuGet.ProjectManagement.NuGetProject,System.Threading.CancellationToken)">
            <summary>
            Returns all installed packages in order of dependency. Packages with no dependencies come first.
            </summary>
            <remarks>Packages with unresolved dependencies are NOT returned since they are not valid.</remarks>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.GetDependencies(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo})">
            <summary>
            Filter down the reinstall list to just the ones we need to reinstall (i.e. the dependencies)
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.CollectDependencies(System.Collections.Generic.HashSet{System.String},System.String,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Int32)">
            <summary>
            A walk through the dependencies to collect the additional package identities that are involved in the current set of packages to be installed
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewInstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            Gives the preview as a list of NuGetProjectActions that will be performed to install
            <paramref name="packageIdentity" /> into <paramref name="nuGetProject" />
            <paramref name="resolutionContext" /> and <paramref name="nuGetProjectContext" /> are used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.GetSourceRepository(NuGet.Packaging.Core.PackageIdentity,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Common.ILogger)">
            <summary>
            Check all sources in parallel to see if the package exists while respecting the order of the list.
            This is only used by PreviewInstall with DependencyBehavior.Ignore.
            Since, resolver gather is not used when dependencies are not used,
            we simply get the source repository using MetadataResource.Exists
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewUninstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.UninstallationContext,NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Gives the preview as a list of NuGetProjectActions that will be performed to uninstall
            <paramref name="packageId" /> into <paramref name="nuGetProject" />
            <paramref name="uninstallationContext" /> and <paramref name="nuGetProjectContext" /> are used in the
            process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewUninstallPackageAsync(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.UninstallationContext,NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Gives the preview as a list of <see cref="T:NuGet.PackageManagement.NuGetProjectAction" /> that will be performed to uninstall
            <paramref name="packageIdentity" /> into <paramref name="nuGetProject" />
            <paramref name="uninstallationContext" /> and <paramref name="nuGetProjectContext" /> are used in the
            process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.ExecuteNuGetProjectActionsAsync(System.Collections.Generic.IEnumerable{NuGet.ProjectManagement.NuGetProject},System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Executes the list of <paramref name="nuGetProjectActions" /> on list of <paramref name="nuGetProjects" /> , which is
            likely obtained by calling into
            <see
                cref="!:PreviewInstallPackageAsync(IEnumerable&lt;NuGetProject&gt;,string,ResolutionContext,INuGetProjectContext,SourceRepository,IEnumerable&lt;SourceRepository&gt;,CancellationToken)" />
            <paramref name="nuGetProjectContext" /> is used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.ExecuteNuGetProjectActionsAsync(NuGet.ProjectManagement.NuGetProject,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Executes the list of <paramref name="nuGetProjectActions" /> on <paramref name="nuGetProject" /> , which is
            likely obtained by calling into
            <see
                cref="M:NuGet.PackageManagement.NuGetPackageManager.PreviewInstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)" />
            <paramref name="nuGetProjectContext" /> is used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.ExecuteNuGetProjectActionsAsync(NuGet.ProjectManagement.NuGetProject,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,System.Threading.CancellationToken)">
            <summary>
            Executes the list of <paramref name="nuGetProjectActions" /> on <paramref name="nuGetProject" /> , which is
            likely obtained by calling into
            <see
                cref="M:NuGet.PackageManagement.NuGetPackageManager.PreviewInstallPackageAsync(NuGet.ProjectManagement.NuGetProject,System.String,NuGet.PackageManagement.ResolutionContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.SourceRepository,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)" />
            <paramref name="nuGetProjectContext" /> is used in the process.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PreviewBuildIntegratedProjectActionsAsync(NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Run project actions for build integrated projects.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.ExecuteBuildIntegratedProjectActionsAsync(NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Run project actions for build integrated projects.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.RestorePackageAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.Threading.CancellationToken)">
            <summary>
            RestorePackage is only allowed on a folderNuGetProject. In most cases, one will simply use the
            packagesFolderPath from NuGetPackageManager
            to create a folderNuGetProject before calling into this method
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PackageExistsInPackagesFolder(NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.PackageSaveMode)">
            <summary>
            Checks whether package exists in packages folder and verifies that nupkg and nuspec are present as specified by packageSaveMode
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetPackageManager.PackageExistsInAnotherNuGetProject(NuGet.ProjectManagement.NuGetProject,NuGet.Packaging.Core.PackageIdentity,NuGet.PackageManagement.ISolutionManager,System.Threading.CancellationToken)">
            <summary>
            Checks if package <paramref name="packageIdentity" /> that is installed in
            project <paramref name="nuGetProject" /> is also installed in any
            other projects in the solution.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetProjectActionType">
            <summary>
            Enum for the type of NuGetProjectAction
            </summary>
        </member>
        <member name="F:NuGet.PackageManagement.NuGetProjectActionType.Install">
            <summary>
            Install
            </summary>
        </member>
        <member name="F:NuGet.PackageManagement.NuGetProjectActionType.Uninstall">
            <summary>
            Uninstall
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetProjectAction">
            <summary>
            NuGetProjectAction
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetProjectAction.PackageIdentity">
            <summary>
            PackageIdentity on which the action is performed
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetProjectAction.NuGetProjectActionType">
            <summary>
            Type of NuGetProjectAction. Install/Uninstall
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetProjectAction.SourceRepository">
            <summary>
            For NuGetProjectActionType.Install, SourceRepository from which the package should be installed
            For NuGetProjectActionType.Uninstall, this will be null
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetProjectAction.Project">
            <summary>
            NugetProject for which the action is created
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackageDownloader">
            <summary>
            Abstracts the logic to get a package stream for a given package identity from a given source repository
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageDownloader.GetDownloadResourceResultAsync(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult"/> for a given <paramref name="packageIdentity" />
            from the given <paramref name="sources" />.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageDownloader.GetDownloadResourceResultAsync(NuGet.Protocol.Core.Types.SourceRepository,NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult"/> for a given <paramref name="packageIdentity" /> from the given
            <paramref name="sourceRepository" />.
            </summary>
        </member>
        <member name="F:NuGet.PackageManagement.PackageManagementConstants.DefaultMaxDegreeOfParallelism">
            <summary>
            Default MaxDegreeOfParallelism to use for restores and other threaded operations.
            </summary>
        </member>
        <member name="F:NuGet.PackageManagement.PackageManagementConstants.DefaultRequestTimeout">
            <summary>
            Default amount of time a source request can take before timing out. This includes both UNC shares
            and online sources.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcher.GetPackagesAsync(System.Collections.Generic.IEnumerable{NuGet.PackageManagement.NuGetProjectAction},NuGet.ProjectManagement.FolderNuGetProject,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Download all needed packages for install actions.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcher.LogFetchMessages(System.Collections.Generic.IEnumerable{NuGet.PackageManagement.PackagePreFetcherResult},System.String,NuGet.Common.ILogger)">
            <summary>
            Log a message to indicate where each package is being downloaded from
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackagePreFetcherResult.InPackagesFolder">
            <summary>
            True if the result came from the packages folder.
            </summary>
            <remarks>Not thread safe.</remarks>
        </member>
        <member name="P:NuGet.PackageManagement.PackagePreFetcherResult.Package">
            <summary>
            Package identity.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackagePreFetcherResult.Source">
            <summary>
            PackageSource for the download. This is null if the packages folder was used.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackagePreFetcherResult.IsComplete">
            <summary>
            True if the download is complete.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcherResult.#ctor(System.Threading.Tasks.Task{NuGet.Protocol.Core.Types.DownloadResourceResult},NuGet.Packaging.Core.PackageIdentity,NuGet.Configuration.PackageSource)">
            <summary>
            Create a PreFetcher result for a downloaded package.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcherResult.#ctor(System.String,NuGet.Packaging.Core.PackageIdentity)">
            <summary>
            Create a PreFetcher result for a package in the packages folder.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcherResult.EnsureResultAsync">
            <summary>
            A safe wait for the download task. Exceptions are caught and stored.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagePreFetcherResult.GetResultAsync">
            <summary>
            Ensure and retrieve the download result.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.Strings">
            <summary>
               A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResourceManager">
            <summary>
               Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.Culture">
            <summary>
               Overrides the current thread's CurrentUICulture property for all
               resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.AnotherNuGetProjectWithSameNameExistsInSolution">
            <summary>
               Looks up a localized string similar to Another NuGetProject with the same name &apos;{0}&apos; exists in solution.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.AttemptingToGatherDependencyInfo">
            <summary>
               Looks up a localized string similar to Attempting to gather dependency information for package &apos;{0}&apos; with respect to project &apos;{1}&apos;, targeting &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.AttemptingToGatherDependencyInfoForMultiplePackages">
            <summary>
               Looks up a localized string similar to Attempting to gather dependency information for multiple packages with respect to project &apos;{0}&apos;, targeting &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.AttemptingToResolveDependencies">
            <summary>
               Looks up a localized string similar to Attempting to resolve dependencies for package &apos;{0}&apos; with DependencyBehavior &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.AttemptingToResolveDependenciesForMultiplePackages">
            <summary>
               Looks up a localized string similar to Attempting to resolve dependencies for multiple packages..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.BuildIntegratedPackageRestoreFailed">
            <summary>
               Looks up a localized string similar to Package restore failed for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.BuildIntegratedPackageRestoreStarted">
            <summary>
               Looks up a localized string similar to Restoring packages for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.BuildIntegratedPackageRestoreSucceeded">
            <summary>
               Looks up a localized string similar to Package restore completed successfully for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.DownloadResourceNotFound">
            <summary>
               Looks up a localized string similar to Cannot download packages from &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.DownloadStreamNotAvailable">
            <summary>
               Looks up a localized string similar to Package stream for &apos;{0}&apos; cannot be found at &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.Exception_PackageNotFound">
            <summary>
               Looks up a localized string similar to Unable to find package &apos;{0}&apos; at source &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ExceptionType">
            <summary>
               Looks up a localized string similar to Exception Type.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ExceptionWhenTryingToAddSource">
            <summary>
               Looks up a localized string similar to Exception &apos;{0}&apos; thrown when trying to add source &apos;{1}&apos;. Please verify all your online package sources are available..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.FoundPackageInPackagesFolder">
            <summary>
               Looks up a localized string similar to Found package &apos;{0} {1}&apos; in &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.GatherTotalTime">
            <summary>
               Looks up a localized string similar to Gathering dependency information took {0}.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.InstalledPackage">
            <summary>
               Looks up a localized string similar to Installed package &apos;{0}&apos; to project.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.InstallingPackage">
            <summary>
               Looks up a localized string similar to Installing package &apos;{0}&apos; to project.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.InvalidNullSettingsOperation">
            <summary>
               Looks up a localized string similar to &apos;{0}&apos; cannot be called on a NullSettings. This may be caused on account of insufficient permissions to read or write to &apos;%AppData%\NuGet\NuGet.config&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.MultiplePackageInstallOrUpdateHasToBeAnUpdate">
            <summary>
               Looks up a localized string similar to When updating multiple packages, dependency behavior has to be DependencyBehavior.Highest.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.MultiplePackageTypesNotSupported">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; has multiple package types, which is not supported..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NewerVersionAlreadyReferenced">
            <summary>
               Looks up a localized string similar to Already referencing a newer version of &apos;{0}&apos;...
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NoLatestVersionFound">
            <summary>
               Looks up a localized string similar to No latest version found for &apos;{0}&apos; for the given source repositories and resolution context.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NoNuGetProjectWithSpecifiedName">
            <summary>
               Looks up a localized string similar to No NuGetProject is available with specified name &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NoPackagesInProject">
            <summary>
               Looks up a localized string similar to No packages were found in packages.config for project &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NoPackageUpdates">
            <summary>
               Looks up a localized string similar to No package updates are available from the current package source for project &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NoUpdatesAvailable">
            <summary>
               Looks up a localized string similar to There are no new updates available..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NugetActionsTotalTime">
            <summary>
               Looks up a localized string similar to Executing nuget actions took {0}.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.NuGetProjectDoesNotHaveName">
            <summary>
               Looks up a localized string similar to NuGetProject does not have &apos;Name&apos; set in metadata. It should be set and it should be unique.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.OneOrMorePackagesNotFound">
            <summary>
               Looks up a localized string similar to One or more packages not found.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageCancelledFromSource">
            <summary>
               Looks up a localized string similar to Getting package &apos;{0}&apos; from source &apos;{1}&apos; was cancelled..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageCouldNotBeInstalled">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; could not be installed.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageHasDependent">
            <summary>
               Looks up a localized string similar to Unable to uninstall &apos;{0}&apos; because &apos;{1}&apos; depends on it..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageHasDependents">
            <summary>
               Looks up a localized string similar to Unable to uninstall &apos;{0}&apos; because &apos;{1}&apos; depend on it..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageNotFound">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; is not found.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageNotFoundInPrimarySources">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; is not found in the following primary source(s): &apos;{1}&apos;. Please verify all your online package sources are available (OR) package id, version are specified correctly..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageNotFoundOnSource">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; is not found on source &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackagesConfigAllowedVersionConflict">
            <summary>
               Looks up a localized string similar to Unable to resolve &apos;{0}&apos;. An additional constraint &apos;{1}&apos; defined in {2} prevents this operation..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackagesConfigAllowedVersions">
            <summary>
               Looks up a localized string similar to Applying constraint &apos;{0}&apos; defined in &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackagesCouldNotBeInstalled">
            <summary>
               Looks up a localized string similar to Packages could not be installed.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.PackageToBeUninstalledCouldNotBeFound">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; to be uninstalled could not be found in project &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ParameterCannotBeZeroOrNegative">
            <summary>
               Looks up a localized string similar to Parameter cannot be zero or negative.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolutionSuccessfulNoAction">
            <summary>
               Looks up a localized string similar to Resolution was successful but resulted in no action.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolvedActionsToInstallPackage">
            <summary>
               Looks up a localized string similar to Resolved actions to install package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolvedActionsToUninstallPackage">
            <summary>
               Looks up a localized string similar to Resolved actions to uninstall package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolvingActionsToInstallOrUpdateMultiplePackages">
            <summary>
               Looks up a localized string similar to Resolving actions install multiple packages.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolvingActionsToInstallPackage">
            <summary>
               Looks up a localized string similar to Resolving actions to install package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.ResolvingActionsToUninstallPackage">
            <summary>
               Looks up a localized string similar to Resolving actions to uninstall package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.RestoreFailedRollingBack">
            <summary>
               Looks up a localized string similar to Package restore failed. Rolling back package changes for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.RestoringPackage">
            <summary>
               Looks up a localized string similar to Restoring NuGet package {0}..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.RetrievingPackageStart">
            <summary>
               Looks up a localized string similar to Retrieving package &apos;{0} {1}&apos; from &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.SolutionDirectoryNotAvailable">
            <summary>
               Looks up a localized string similar to Solution is not opened or not saved. Please ensure you have an open and saved solution..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.SolutionManagerNotAvailableForUninstall">
            <summary>
               Looks up a localized string similar to Uninstall is not supported when SolutionManager is not available.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.SuccessfullyInstalled">
            <summary>
               Looks up a localized string similar to Successfully installed &apos;{0}&apos; to {1}.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.SuccessfullyUninstalled">
            <summary>
               Looks up a localized string similar to Successfully uninstalled &apos;{0}&apos; from {1}.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnableToGatherDependencyInfo">
            <summary>
               Looks up a localized string similar to Unable to gather dependency information for package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnableToGatherDependencyInfoForMultiplePackages">
            <summary>
               Looks up a localized string similar to Unable to gather dependency information for multiple packages.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnableToGatherPackageFromSource">
            <summary>
               Looks up a localized string similar to Unable to gather package &apos;{0}&apos; from source &apos;{1}&apos;. Please verify all your online package sources are available. .
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnableToResolveDependencyInfo">
            <summary>
               Looks up a localized string similar to Unable to resolve dependencies for package &apos;{0}&apos; with DependencyBehavior &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnableToResolveDependencyInfoForMultiplePackages">
            <summary>
               Looks up a localized string similar to Unable to resolve dependencies for multiple packages.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnknownPackage">
            <summary>
               Looks up a localized string similar to Unable to find package &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnknownPackageSpecificVersion">
            <summary>
               Looks up a localized string similar to Unable to find version &apos;{1}&apos; of package &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnknownSource">
            <summary>
               Looks up a localized string similar to Source &apos;{0}&apos; not found. Please provide an HTTP or local source..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnknownSourceType">
            <summary>
               Looks up a localized string similar to Unsupported type of source &apos;{0}&apos;. Please provide an HTTP or local source..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnknownSourceWithId">
            <summary>
               Looks up a localized string similar to Unable to find package &apos;{0}&apos; at source &apos;{1}&apos;. Source not found..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnsupportedPackageFeature">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; uses features that are not supported by the current version of NuGet. To upgrade NuGet, see http://docs.nuget.org/consume/installing-nuget..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.UnsupportedPackageType">
            <summary>
               Looks up a localized string similar to Package &apos;{0}&apos; has a package type &apos;{1}&apos; that is not supported by project &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.Warning_ErrorFindingRepository">
            <summary>
               Looks up a localized string similar to Error finding repository for &apos;{0}&apos;: {1}.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.Strings.Warning_RollingBack">
            <summary>
               Looks up a localized string similar to Install failed. Rolling back....
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.OriginalLockFile">
            <summary>
            Before the update
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.RestoreResult">
            <summary>
            After applying the changes
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.RestoreResultPair">
            <summary>
            After applying the changes
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.Sources">
            <summary>
            Sources used for package restore.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.OriginalActions">
            <summary>
            Original user actions.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.BuildIntegratedProjectAction.InstallationContext">
            <summary>
            The context necessary for installing a package.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.BuildIntegratedRestoreUtility">
            <summary>
            Helper class for calling the RestoreCommand
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.BuildIntegratedRestoreUtility.GetPackagesToExecuteInitPs1(NuGet.Commands.RestoreResult)">
            <summary>
            Determine what packages need to have their init.ps1 scripts executed based on the provided restore result.
            When a restore happens, new packages can be introduced (because the project.json was updated since the last
            restore) or existing packages can be installed (because the global packages folder was cleared or a restore
            has never been run on an existing project.json). In both of these cases, the init.ps1 scripts should be
            executed. Also, the init.ps1 scripts should be executed in dependency order, however it is the
            resposibility of <see cref="M:NuGet.PackageManagement.BuildIntegratedRestoreUtility.ExecuteInitPs1ScriptsAsync(NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},NuGet.Packaging.FallbackPackagePathResolver,NuGet.ProjectManagement.INuGetProjectContext)"/>
            to do this.
            </summary>
            <param name="restoreResult">The restore result to examine.</param>
            <returns>The packages to execute init.ps1 scripts.</returns>
        </member>
        <member name="M:NuGet.PackageManagement.BuildIntegratedRestoreUtility.GetAddedPackages(NuGet.ProjectModel.LockFile,NuGet.ProjectModel.LockFile)">
            <summary>
            Find all packages added to <paramref name="updatedLockFile"/>.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.BuildIntegratedRestoreUtility.GetParentProjectsInClosure(System.Collections.Generic.IReadOnlyList{NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject},NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,NuGet.ProjectModel.DependencyGraphSpec)">
            <summary>
            Find the list of parent projects which directly or indirectly reference the child project.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.DependencyGraphRestoreUtility">
            <summary>
            Supporting methods for restoring sets of projects that implement <see cref="T:NuGet.ProjectManagement.IDependencyGraphProject"/>. This
            code is used by Visual Studio to execute restores for solutions that have mixtures of UWP project.json,
            packages.config, and PackageReference-type projects.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.RestoreAsync(NuGet.PackageManagement.ISolutionManager,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore a solution and cache the dg spec to context.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.RestoreAsync(NuGet.PackageManagement.ISolutionManager,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.String,NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore a solution and cache the dg spec to context.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.RestoreAsync(NuGet.ProjectModel.DependencyGraphSpec,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore a dg spec. This will not update the context cache.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.PreviewRestoreAsync(NuGet.PackageManagement.ISolutionManager,NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,NuGet.ProjectModel.PackageSpec,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore without writing the lock file
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.PreviewRestoreAsync(NuGet.PackageManagement.ISolutionManager,NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,NuGet.ProjectModel.PackageSpec,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},System.String,NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore without writing the lock file
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.RestoreProjectAsync(NuGet.PackageManagement.ISolutionManager,NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject,NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,System.Action{NuGet.Protocol.Core.Types.SourceCacheContext},System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.Configuration.ISettings,NuGet.Common.ILogger,System.Threading.CancellationToken)">
            <summary>
            Restore a build integrated project and update the lock file
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.DependencyGraphRestoreUtility.GetRestoreContext(NuGet.ProjectManagement.DependencyGraphCacheContext,NuGet.Commands.RestoreCommandProvidersCache,NuGet.Configuration.ISettings,NuGet.Protocol.Core.Types.SourceCacheContext,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourceRepository},NuGet.ProjectModel.DependencyGraphSpec,System.String)">
            <summary>
            Create a restore context.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackageManagementContext">
            <summary>
            Context for Package Management
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackageManagementContext.SourceRepositoryProvider">
            <summary>
            Source repository provider
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackageManagementContext.VsSolutionManager">
            <summary>
            VS solution manager
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackageManagementContext.Settings">
            <summary>
            NuGet config settings
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackageManagementContext.SourceControlManagerProvider">
            <summary>
            SourceControlManager provider
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackageManagementContext.CommonOperations">
            <summary>
            CommonOperations to openfile, and so on
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.ResolutionContext">
            <summary>
            Resolution context such as DependencyBehavior, IncludePrerelease and so on
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolutionContext.#ctor">
            <summary>
            Public constructor to create the resolution context
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolutionContext.#ctor(NuGet.Resolver.DependencyBehavior,System.Boolean,System.Boolean,NuGet.PackageManagement.VersionConstraints)">
            <summary>
            Public constructor to create the resolution context
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolutionContext.#ctor(NuGet.Resolver.DependencyBehavior,System.Boolean,System.Boolean,NuGet.PackageManagement.VersionConstraints,NuGet.PackageManagement.GatherCache)">
            <summary>
            Public constructor to create the resolution context
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolutionContext.DependencyBehavior">
            <summary>
            Determines the dependency behavior
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolutionContext.IncludePrerelease">
            <summary>
            Determines if prerelease may be included in the installation
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolutionContext.IncludeUnlisted">
            <summary>
            Determines if unlisted packages may be included in installation
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolutionContext.VersionConstraints">
            <summary>
            Determines the containts that are placed on package update selection with respect to the installed packages
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolutionContext.GatherCache">
            <summary>
            Gathe cache containing cached packages that can be used across operations.
            Ex: Update-Package updates all packages across all projects, GatherCache stores
            the gathered packages and re-uses them across all sub operations.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.UninstallationContext.RemoveDependencies">
            <summary>
            Determines if dependencies should be uninstalled during package uninstall
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.UninstallationContext.ForceRemove">
            <summary>
            Determines if the package should be uninstalled forcefully even if it may break the build
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.IPackageProjectEventsProvider">
            <summary>
            Internal version of the public IVsPackageInstallerProjectEvents
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackageProjectEventArgs">
            <summary>
            Event arguments for nuget batch events.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackageProjectEvents">
            <summary>
            Package project events relayed to the public IVsPackageInstallerProjectEvents.
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.PackageProjectEvents.BatchStart">
            <summary>
            Raised when batch processing of install/ uninstall packages starts at a project level
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.PackageProjectEvents.BatchEnd">
            <summary>
            Raised when batch processing of install/ uninstall packages ends at a project level
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackageProjectEventsProvider">
            <summary>
            Provider for the PackageEvents singleton
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.ActionsExecutedEventArgs">
            <summary>
            The event args of the ActionsExecuted event.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ActionsExecutedEventArgs.Actions">
            <summary>
            The list of actions that are executed.
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.IDeleteOnRestartManager">
            <summary>
            Exposes methods which mark partially deleted packages and deletes them.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IDeleteOnRestartManager.GetPackageDirectoriesMarkedForDeletion">
            <summary>
            Gets the list of package directories that are still need to be deleted in the
            local package repository.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IDeleteOnRestartManager.CheckAndRaisePackageDirectoriesMarkedForDeletion">
            <summary>
            Checks for any pacakge directories that are pending to be deleted and raises the
            <see cref="E:NuGet.PackageManagement.IDeleteOnRestartManager.PackagesMarkedForDeletionFound"/> event.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IDeleteOnRestartManager.MarkPackageDirectoryForDeletion(NuGet.Packaging.Core.PackageIdentity,System.String,NuGet.ProjectManagement.INuGetProjectContext)">
            <summary>
            Marks package directory for future removal if it was not fully deleted during the normal uninstall process
            if the directory does not contain any added or modified files.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IDeleteOnRestartManager.DeleteMarkedPackageDirectories(NuGet.ProjectManagement.INuGetProjectContext)">
            <summary>
            Attempts to remove marked package directories that were unable to be fully deleted during the original
            uninstall.
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.IDeleteOnRestartManager.PackagesMarkedForDeletionFound">
            <summary>
            Occurs when it is detected that the one or more packages are marked for deletion in the current solution.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.IPackageRestoreManager.IsCurrentSolutionEnabledForRestore">
            <summary>
            Gets a value indicating whether the current solution is configured for Package Restore mode.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.EnableCurrentSolutionForRestore(System.Boolean)">
            <summary>
            Configures the current solution for Package Restore mode.
            </summary>
            <param name="fromActivation">
            if set to <c>false</c>, the method will not show any error message, and will
            not set package restore consent.
            </param>
        </member>
        <member name="E:NuGet.PackageManagement.IPackageRestoreManager.PackagesMissingStatusChanged">
            <summary>
            Occurs when it is detected that the packages are missing or restored for the current solution.
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.IPackageRestoreManager.PackageRestoredEvent">
            <summary>
            PackageRestoredEvent which is raised after a package is restored.
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.IPackageRestoreManager.PackageRestoreFailedEvent">
            <summary>
            PackageRestoredEvent which is raised if a package restore failed.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.GetPackagesInSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get the packages in the solution given the <paramref name="solutionDirectory"></paramref>.
            </summary>
            <returns>
            Returns a list of package references and the corresponding project names on which
            each package is installed, alongwith a bool which determines if the package is missing
            </returns>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.GetPackagesRestoreData(System.String,System.Collections.Generic.Dictionary{NuGet.Packaging.PackageReference,System.Collections.Generic.List{System.String}})">
            <summary>
            Get packages restore data for given package references.
            </summary>
            <param name="solutionDirectory">Current solution directory</param>
            <param name="packageReferencesDict">Dictionary of package reference with project names</param>
            <returns>List of packages restore data with missing package details.</returns>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.RaisePackagesMissingEventForSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Checks the current solution if there is any package missing.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.RestoreMissingPackagesInSolutionAsync(System.String,NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Restores the missing packages for the current solution.
            </summary>
            <remarks>
            Best use case is the restore button that shows up in the UI or powershell when certain packages
            are missing
            </remarks>
            <returns>Returns true if atleast one package was restored.</returns>
        </member>
        <member name="M:NuGet.PackageManagement.IPackageRestoreManager.RestoreMissingPackagesAsync(System.String,System.Collections.Generic.IEnumerable{NuGet.PackageManagement.PackageRestoreData},NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext,System.Threading.CancellationToken)">
            <summary>
            Restores the package references if they are missing
            </summary>
            <param name="packages">
            This parameter is the list of package referneces mapped to the list of
            project names a package is installed on. This is most likely obtained by calling
            GetPackagesInSolutionAsync
            </param>
            <remarks>
            Best use case is when GetPackagesInSolutionAsync was already called, the result can be used
            in this method
            </remarks>
            <returns>
            Returns true if at least one package is restored. Raised package restored failed event with the
            list of project names.
            </returns>
        </member>
        <member name="T:NuGet.PackageManagement.PackageRestoredEventArgs">
            <summary>
            If 'Restored' is false, it means that the package was already restored
            If 'Restored' is true, the package was restored and successfully
            </summary>
        </member>
        <member name="E:NuGet.PackageManagement.ISolutionManager.ActionsExecuted">
            <summary>
            Event raised after user actions are executed.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.SolutionDirectory">
            <summary>
            Gets the current open solution directory, can only be called from the main UI thread.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.DefaultNuGetProjectName">
            <summary>
            Gets the name of the default <see cref="T:NuGet.ProjectManagement.NuGetProject" />. Default NuGetProject is the selected NuGetProject
            in the IDE.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.DefaultNuGetProject">
            <summary>
            Gets the default <see cref="T:NuGet.ProjectManagement.NuGetProject" />. Default NuGetProject is the selected NuGetProject in the IDE.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.IsSolutionOpen">
            <summary>
            Returns true if the solution is open
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.IsSolutionAvailable">
            <summary>
            Returns true if the solution is available to manage nuget packages.
            That is, if the solution is open and a solution file is available.
            For solutions with only BuildIntegratedProject(s), and a globalPackagesFolder which is
            not a relative path, it will return true, even if the solution file is not available.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ISolutionManager.IsSolutionDPLEnabled">
            <summary>
            Returns true if the solution is loaded with DPL enabled.
            That is, when no project is loaded by default.
            This is only applicable for VS15, for VS14 it will always return false.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ISolutionManager.GetNuGetProjectSafeName(NuGet.ProjectManagement.NuGetProject)">
            <summary>
            Get the safe name of the specified <see cref="T:NuGet.ProjectManagement.NuGetProject" /> which guarantees not to conflict with other
            projects.
            </summary>
            <returns>
            Returns the simple name if there are no conflicts. Otherwise returns the unique name.
            </returns>
        </member>
        <member name="M:NuGet.PackageManagement.ISolutionManager.GetNuGetProject(System.String)">
            <summary>
            Gets the <see cref="T:NuGet.ProjectManagement.NuGetProject" /> corresponding to the safe name passed in
            </summary>
            <param name="nuGetProjectSafeName">
            nuGetProjectSafeName is the nuGetProject's unique name if one is
            available or its name.
            </param>
            <returns>
            Returns the <see cref="T:NuGet.ProjectManagement.NuGetProject" /> in this solution manager corresponding to the safe name
            passed in.
            </returns>
        </member>
        <member name="M:NuGet.PackageManagement.ISolutionManager.OnActionsExecuted(System.Collections.Generic.IEnumerable{NuGet.PackageManagement.ResolvedAction})">
            <summary>
            Fires ActionsExecuted event.
            </summary>
            <param name="actions"></param>
        </member>
        <member name="M:NuGet.PackageManagement.ISolutionManager.SaveProject(NuGet.ProjectManagement.NuGetProject)">
            <summary>
            Saves the specified project
            </summary>
            <param name="nuGetProject"></param>
        </member>
        <member name="M:NuGet.PackageManagement.ISolutionManager.EnsureSolutionIsLoaded">
            <summary>
            It ensure to completely load the solution before continue if it was loaded with DPL.
            That is, not all the projects were loaded when solution was open.
            This will only be applicable for VS15 and will do nothing for VS14.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.GetPackagesInSolutionAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Get the missing packages in the solution given the <paramref name="solutionDirectory"></paramref>.
            </summary>
            <returns>
            Returns a read-only dictionary of missing package references and the corresponding project names on which
            each missing package is installed.
            </returns>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.GetPackagesRestoreData(System.String,System.Collections.Generic.Dictionary{NuGet.Packaging.PackageReference,System.Collections.Generic.List{System.String}})">
            <summary>
            Get packages restore data for given package references.
            </summary>
            <param name="solutionDirectory">Current solution directory</param>
            <param name="packageReferencesDict">Dictionary of package reference with project names</param>
            <returns>List of packages restore data with missing package details.</returns>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.RestoreMissingPackagesInSolutionAsync(System.String,NuGet.ProjectManagement.INuGetProjectContext,System.Threading.CancellationToken)">
            <summary>
            Restores missing packages for the entire solution
            </summary>
            <returns></returns>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.RestoreMissingPackagesAsync(NuGet.PackageManagement.PackageRestoreContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext)">
            <summary>
            The static method which takes in all the possible parameters
            </summary>
            <returns>Returns true if at least one of the packages needed to be restored and got restored</returns>
            <remarks>
            Best use case is 'nuget.exe restore .sln' where there is no project loaded and there is no SolutionManager.
            The references are obtained by parsing of solution file and by using PackagesConfigReader. In this case,
            you don't construct an object of PackageRestoreManager,
            but just the NuGetPackageManager using constructor that does not need the SolutionManager, and, optionally
            register to events and/or specify the source repositories
            </remarks>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.ThrottledPackageRestoreAsync(System.Collections.Generic.HashSet{NuGet.Packaging.PackageReference},NuGet.PackageManagement.PackageRestoreContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext)">
            <summary>
            ThrottledPackageRestoreAsync method throttles the number of tasks created to perform package restore in
            parallel
            The maximum number of parallel tasks that may be created can be specified via
            <paramref name="packageRestoreContext" />
            The method creates a ConcurrentQueue of passed in <paramref name="packageReferences" />. And, creates a
            fixed number of tasks
            that dequeue from the ConcurrentQueue and perform package restore. So, this method should pre-populate the
            queue and must not enqueued to by other methods
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.PackageRestoreRunnerAsync(System.Collections.Concurrent.ConcurrentQueue{NuGet.Packaging.PackageReference},NuGet.PackageManagement.PackageRestoreContext,NuGet.ProjectManagement.INuGetProjectContext,NuGet.Protocol.Core.Types.PackageDownloadContext)">
            <summary>
            This is the runner which dequeues package references from <paramref name="packageReferencesQueue" />, and
            performs package restore
            Note that this method should only Dequeue from the concurrent queue and not Enqueue
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.ThrottledCopySatelliteFilesAsync(System.Collections.Generic.HashSet{NuGet.Packaging.PackageReference},NuGet.PackageManagement.PackageRestoreContext,NuGet.ProjectManagement.INuGetProjectContext)">
            <summary>
            ThrottledCopySatelliteFilesAsync method throttles the number of tasks created to perform copy satellite
            files in parallel
            The maximum number of parallel tasks that may be created can be specified via
            <paramref name="packageRestoreContext" />
            The method creates a ConcurrentQueue of passed in <paramref name="packageReferences" />. And, creates a
            fixed number of tasks
            that dequeue from the ConcurrentQueue and perform copying of satellite files. So, this method should
            pre-populate the queue and must not enqueued to by other methods
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackageRestoreManager.CopySatelliteFilesRunnerAsync(System.Collections.Concurrent.ConcurrentQueue{NuGet.Packaging.PackageReference},NuGet.PackageManagement.PackageRestoreContext,NuGet.ProjectManagement.INuGetProjectContext)">
            <summary>
            This is the runner which dequeues package references from <paramref name="packageReferencesQueue" />, and
            performs copying of satellite files
            Note that this method should only Dequeue from the concurrent queue and not Enqueue
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackagesMarkedForDeletionEventArgs">
            <summary>
            Event arguments for <see cref="E:NuGet.PackageManagement.IDeleteOnRestartManager.PackagesMarkedForDeletionFound"/> event.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.PackagesMarkedForDeletionEventArgs.DirectoriesMarkedForDeletion">
            <summary>
            Gets the directories which are marked for deletion.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PackagesMarkedForDeletionEventArgs.#ctor(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Creates a new instance of <see cref="T:NuGet.PackageManagement.PackagesMarkedForDeletionEventArgs"/>.
            </summary>
            <param name="directoriesMarkedForDeletion">The directory paths that are marked for deletion.</param>
        </member>
        <member name="T:NuGet.PackageManagement.GatherCache">
            <summary>
            GatherCache contains cached results from DependencyInfoResource providers
            This class is for internal use or testing only.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.GatherCache.AddPackageFromSingleVersionLookup(NuGet.Configuration.PackageSource,NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourcePackageDependencyInfo)">
            <summary>
            Add a single package
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.GatherCache.AddAllPackagesForId(NuGet.Configuration.PackageSource,System.String,NuGet.Frameworks.NuGetFramework,System.Collections.Generic.List{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo})">
            <summary>
            Add the full list of versions for a package
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.GatherCache.GetPackage(NuGet.Configuration.PackageSource,NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Retrieve an exact version of a package
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.GatherCache.GetPackages(NuGet.Configuration.PackageSource,System.String,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Retrieve all versions of a package id
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.GatherCache.GatherSingleCacheKey">
            <summary>
            Cache key for a package id and version
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.GatherCache.GatherAllCacheKey">
            <summary>
            Cache key for a package id and all versions
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.GatherCacheResult">
            <summary>
            The result of a cache look up. HasEntry determines if the query has already been made. 
            If a result has zero packages HasEntry will be true, but Packages will be empty.
            If the query has not been done HasEntry will be false.
            This class is for internal use or testing only.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherCacheResult.HasEntry">
            <summary>
            True if an entry has been added (including a result with zero packages).
            This will be false if the package has not been searched for in the source.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherCacheResult.Packages">
            <summary>
            Cached packages
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.TargetFramework">
            <summary>
            Project target framework
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.PrimarySources">
            <summary>
            Primary sources - Primary targets must exist here.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.AllSources">
            <summary>
            All sources - used for dependencies
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.PackagesFolderSource">
            <summary>
            Packages folder
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.PrimaryTargetIds">
            <summary>
            Target ids
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.PrimaryTargets">
            <summary>
            Targets with an id and version
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.InstalledPackages">
            <summary>
            Already installed packages
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.AllowDowngrades">
            <summary>
            If false dependencies from downgrades will be ignored.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.ResolutionContext">
            <summary>
            Resolution context containing the GatherCache and DependencyBehavior.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.ProjectContext">
            <summary>
            Project context for logging
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.IsUpdateAll">
            <summary>
            If true, missing primary targets will be ignored.
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.GatherContext.Log">
            <summary>
            Logging adapter
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.GatherExceptionHelpers.ThrowIfVersionIsDisallowedByPackagesConfig(System.String,System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},NuGet.Common.ILogger)">
            <summary>
            Throw if packages.config contains an AllowedVersions entry for the target, 
            and no packages outside of that range have been found.
            </summary>
            <param name="target">target package id</param>
            <param name="packagesConfig">entries from packages.config</param>
            <param name="availablePackages">gathered packages</param>
        </member>
        <member name="M:NuGet.PackageManagement.GatherExceptionHelpers.ThrowIfVersionIsDisallowedByPackagesConfig(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},NuGet.Common.ILogger)">
            <summary>
            Throw if packages.config contains an AllowedVersions entry for the target, 
            and no packages outside of that range have been found.
            </summary>
            <param name="targets">target package ids</param>
            <param name="packagesConfig">entries from packages.config</param>
            <param name="availablePackages">gathered packages</param>
        </member>
        <member name="M:NuGet.PackageManagement.GatherExceptionHelpers.ThrowIfNewerVersionAlreadyReferenced(System.String,System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo})">
            <summary>
            Throw if packages.config contains a newer version of the package already 
            </summary>
            <param name="target">target package id</param>
            <param name="packagesConfig">entries from packages.config</param>
            <param name="availablePackages">gathered packages</param>
        </member>
        <member name="T:NuGet.PackageManagement.PrunePackageTree">
            <summary>
            Helpers to reduce down the gathered package dependency info to the allowed set
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.PrunePrereleaseExceptAllowed(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Boolean)">
            <summary>
            Remove some of the prerelease packages in update scenarios
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.PrunePreleaseForStableTargets(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity})">
            <summary>
            Remove all prerelease packages for stable targets
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.RemoveAllVersionsForIdExcept(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},NuGet.Packaging.Core.PackageIdentity)">
            <summary>
            Remove all versions of a package id from the list, except for the target version
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.RemoveAllPrereleaseVersionsForId(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.String)">
            <summary>
            Keep only stable versions of a package
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.RemoveAllVersionsLessThan(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},NuGet.Packaging.Core.PackageIdentity)">
            <summary>
            Clear out all versions less than the minimuim. This can be used to prevent downgrading
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.PrunePackageTree.PruneByPrimaryTargets(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity})">
            <summary>
            This is used in update scenarios ro remove packages that are of the same Id but different version than the primartTargets 
            </summary>
        </member>
        <member name="P:NuGet.PackageManagement.ResolverGather.MaxDegreeOfParallelism">
            <summary>
            Maximum number of threads to use when gathering packages.
            </summary>
            <remarks>The value must be >= 1.</remarks>
        </member>
        <member name="P:NuGet.PackageManagement.ResolverGather.RequestTimeout">
            <summary>
            Timeout when waiting for source requests
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GatherAsync(NuGet.PackageManagement.GatherContext,System.Threading.CancellationToken)">
            <summary>
            Gather packages
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.StartTasksAndProcessWork(System.Threading.CancellationToken)">
            <summary>
            Start tasks for queued requests and process finished tasks.
            This method will continue until at least 1 task has finished,
            and keep going until all queued requests have been started.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GatherInstalledPackagesAsync(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.HashSet{System.String},System.Threading.CancellationToken)">
            <summary>
            Retrieve already installed packages
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GetClosure(System.Collections.Generic.HashSet{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Collections.Generic.HashSet{NuGet.Protocol.Core.Types.SourcePackageDependencyInfo},System.Collections.Generic.HashSet{System.String})">
            <summary>
            Find the closure of required package ids
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.ProcessResultsAsync">
            <summary>
            Retrieve results from completed tasks
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.StartWorkerTasks(System.Threading.CancellationToken)">
            <summary>
            Load up to the MaxThread count
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GatherPackageAsync(NuGet.PackageManagement.ResolverGather.GatherRequest,System.Threading.CancellationToken)">
            <summary>
            Retrieve the packages from the cache or source
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GatherPackageFromSourceAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.DependencyInfoResource,NuGet.Frameworks.NuGetFramework,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Call the DependencyInfoResource safely
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.ResolverGather.GetNextRequestId">
            <summary>
            Get the current request id number, and increment it for the next count
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.ResolverGather.SourceResource">
            <summary>
            Holds a Source and DependencyInfoResource
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.ResolverGather.GatherRequest">
            <summary>
            Request info
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.ResolverGather.GatherResult">
            <summary>
            Contains the original request along with the resulting packages.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.CollectionExtensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T 
            or a ListWrapperCollection of T. Avoid mutating the return value.
            </summary>
            <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetEvent">
            <summary>
            NuGet Event Ids
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetEventArgs`1">
            <summary>
            Generic EventArg class for NuGet.
            </summary>
            <typeparam name="T">Class type of the argument Arg.</typeparam>
        </member>
        <member name="P:NuGet.PackageManagement.NuGetEventArgs`1.Arg">
            <summary>
            Argument data of the EventArg.
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.NuGetEventArgs`1.#ctor(`0)">
            <summary>
            Constructor for creating NuGetEventArgs object.
            </summary>
            <param name="arg"> Argument to NuGetEventArgs of type T.</param>
        </member>
        <member name="T:NuGet.PackageManagement.NuGetEventTrigger">
            <summary>
            Trigger NuGet Event
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.PackagesFolderPathUtility">
            <summary>
            Static class to help get PackagesFolderPath
            </summary>
        </member>
        <member name="T:NuGet.PackageManagement.UriHelper">
            <summary>
            Static class for UriHelper
            </summary>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.OpenExternalLink(System.Uri)">
            <summary>
            Open external link
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.IsHttpSource(System.String)">
            <summary>
            Determine if Http Source via Uri.TryCreate()
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.IsHttpSource(NuGet.Configuration.PackageSourceProvider)">
            <summary>
            Determine if active package source is http source
            </summary>
            <param name="packageSourceProvider"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.IsHttpSource(System.String,NuGet.Configuration.PackageSourceProvider)">
            <summary>
            Determine if source is http source
            </summary>
            <param name="source"></param>
            <param name="packageSourceProvider"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.IsAnySourceLocal(NuGet.Configuration.PackageSourceProvider,System.String@)">
            <summary>
            Determine is any source is local source
            </summary>
            <param name="packageSourceProvider"></param>
            <param name="localSource"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.PackageManagement.UriHelper.IsAnySourceAvailable(NuGet.Configuration.PackageSourceProvider,System.Boolean)">
            <summary>
            Determine if any source is available
            </summary>
            <param name="packageSourceProvider"></param>
            <param name="checkHttp"></param>
            <returns></returns>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
            <typeparam name="TSource">The type of the list</typeparam>
            <typeparam name="TKey">The type of the sorting key</typeparam>
            <param name="self">This list</param>
            <param name="other">The other list</param>
            <param name="keySelector">The function to extract the key from each item in the list</param>
            <param name="orderComparer">An optional comparer for comparing keys</param>
            <param name="sequenceComparer">An optional comparer for sequences</param>
        </member>
        <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
        </member>
        <member name="T:NuGet.Shared.HashCodeCombiner">
            <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
        </member>
        <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode(System.Object[])">
            <summary>
            Create a unique hash code for the given set of items
            </summary>
        </member>
    </members>
</doc>
